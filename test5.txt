# pip install pymongo pandas openpyxl
import copy
import re
import pandas as pd
from pymongo import MongoClient
from openpyxl import load_workbook

# ----------------------------
# CONFIG
# ----------------------------
MONGO_URI = "mongodb://localhost:27017"
DB_NAME = "your_db"
SRC_COLL = "source_collection"
TGT_COLL = "testdata_collection"

EXCEL_PATH = "/path/to/file.xlsx"
EXCEL_SHEET = "Sheet1"

SOURCE_BATCH_ID = "BATCH_001"
BATCH_ID_PATH = "batchId"

SKIP_BLANKS = True
BATCH_SIZE = 500

# ----------------------------
# HELPERS
# ----------------------------
def extract_paths(obj, parent=""):
    paths = set()
    if isinstance(obj, dict):
        for k, v in obj.items():
            if k == "_id":
                continue
            p = f"{parent}.{k}" if parent else k
            paths.add(p)
            paths.update(extract_paths(v, p))
    elif isinstance(obj, list):
        for item in obj:
            paths.update(extract_paths(item, parent))
    return paths


def set_by_path(doc, path, value):
    parts = path.split(".")
    cur = doc
    for i, part in enumerate(parts):
        last = i == len(parts) - 1
        if part.isdigit():
            idx = int(part)
            if not isinstance(cur, list):
                return
            while len(cur) <= idx:
                cur.append({})
            if last:
                cur[idx] = value
            else:
                if cur[idx] is None:
                    cur[idx] = {}
                cur = cur[idx]
        else:
            if not isinstance(cur, dict):
                return
            if last:
                cur[part] = value
            else:
                if part not in cur or cur[part] is None:
                    cur[part] = {}
                cur = cur[part]


def excel_to_df_preserve_display(xlsx_path, sheet_name):
    wb = load_workbook(xlsx_path, data_only=True)
    ws = wb[sheet_name]

    rows = list(ws.iter_rows(values_only=False))
    headers = [c.value for c in rows[0]]
    data = []

    zero_fmt = re.compile(r"^(0+)$")

    for r in rows[1:]:
        row_dict = {}
        for h, cell in zip(headers, r):
            if h is None:
                continue
            if cell.value is None:
                row_dict[h] = ""
                continue

            fmt = (cell.number_format or "").strip()
            if zero_fmt.match(fmt) and isinstance(cell.value, (int, float)):
                width = len(fmt)
                row_dict[h] = str(int(cell.value)).zfill(width)
            else:
                row_dict[h] = str(cell.value)

        data.append(row_dict)

    return pd.DataFrame(data, columns=headers).fillna("")


def build_case_sensitive_mapping_all(doc, excel_cols):
    all_paths = extract_paths(doc)
    mapping = {col: [] for col in excel_cols}

    for p in all_paths:
        last = p.split(".")[-1]
        if last in mapping:
            mapping[last].append(p)

    return mapping


def mongo_stream_by_batch(coll, batch_path, batch_value):
    query = {batch_path: batch_value}
    while True:
        cursor = coll.find(query, no_cursor_timeout=True).batch_size(200)
        try:
            for doc in cursor:
                yield doc
        finally:
            cursor.close()

# ----------------------------
# MAIN
# ----------------------------
client = MongoClient(MONGO_URI)
db = client[DB_NAME]
src = db[SRC_COLL]
tgt = db[TGT_COLL]

# Read Excel (preserve leading zeros)
df = excel_to_df_preserve_display(EXCEL_PATH, EXCEL_SHEET)
excel_cols = list(df.columns)

doc_gen = mongo_stream_by_batch(src, BATCH_ID_PATH, SOURCE_BATCH_ID)

batch = []
inserted = 0
TARGET_BATCH_ID = f"{SOURCE_BATCH_ID}-test"

for row_idx, row in df.iterrows():
    src_doc = next(doc_gen)
    new_doc = copy.deepcopy(src_doc)
    new_doc.pop("_id", None)

    col_to_paths = build_case_sensitive_mapping_all(src_doc, excel_cols)

    for col in excel_cols:
        paths = col_to_paths.get(col, [])
        if not paths:
            continue

        raw = row[col]
        if SKIP_BLANKS and isinstance(raw, str) and raw.strip() == "":
            continue

        for p in paths:
            set_by_path(new_doc, p, raw)  # raw already string-preserved

    # Replace batchId in target
    set_by_path(new_doc, BATCH_ID_PATH, TARGET_BATCH_ID)

    batch.append(new_doc)

    if len(batch) >= BATCH_SIZE:
        tgt.insert_many(batch)
        inserted += len(batch)
        batch = []

if batch:
    tgt.insert_many(batch)
    inserted += len(batch)

print(f"Done âœ” Excel rows processed: {len(df)} | Inserted: {inserted}")
