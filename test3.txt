# pip install pymongo pandas
import copy
import pandas as pd
from pymongo import MongoClient
from datetime import datetime

# ----------------------------
# CONFIG
# ----------------------------
MONGO_URI = "mongodb://localhost:27017"
DB_NAME = "your_db"
SRC_COLL = "source_collection"
TGT_COLL = "testdata_collection"
CSV_PATH = "/path/to/file.csv"

SKIP_BLANKS = True
BATCH_SIZE = 500

# ----------------------------
# HELPERS
# ----------------------------
def extract_paths(obj, parent=""):
    """Extract all nested MongoDB dot paths (case preserved)."""
    paths = set()

    if isinstance(obj, dict):
        for k, v in obj.items():
            if k == "_id":
                continue
            p = f"{parent}.{k}" if parent else k
            paths.add(p)
            paths.update(extract_paths(v, p))

    elif isinstance(obj, list):
        for item in obj:
            paths.update(extract_paths(item, parent))

    return paths


def set_by_path(doc, path, value):
    """Set value in nested dict/list using dot path."""
    parts = path.split(".")
    cur = doc

    for i, part in enumerate(parts):
        last = i == len(parts) - 1

        if part.isdigit():
            idx = int(part)
            if not isinstance(cur, list):
                return
            while len(cur) <= idx:
                cur.append({})
            if last:
                cur[idx] = value
            else:
                if cur[idx] is None:
                    cur[idx] = {}
                cur = cur[idx]
        else:
            if not isinstance(cur, dict):
                return
            if last:
                cur[part] = value
            else:
                if part not in cur or cur[part] is None:
                    cur[part] = {}
                cur = cur[part]


def coerce(v):
    """Convert CSV string to python type without case changes."""
    if v is None:
        return None
    if isinstance(v, str):
        s = v.strip()
        if s == "":
            return ""
        if s == "true":
            return True
        if s == "false":
            return False
        try:
            if "." in s:
                return float(s)
            return int(s)
        except Exception:
            return s
    return v


def build_case_sensitive_mapping(doc, csv_cols):
    """
    Build mapping:
    CSV column -> Mongo path
    Match ONLY when last key is EXACTLY same (case-sensitive).
    """
    all_paths = extract_paths(doc)
    mapping = {}

    for col in csv_cols:
        matched_path = None
        for p in all_paths:
            if p.split(".")[-1] == col:   # ✅ EXACT match
                matched_path = p
                break
        mapping[col] = matched_path

    return mapping


def mongo_stream(coll):
    """Infinite MongoDB document generator."""
    while True:
        cursor = coll.find({}, no_cursor_timeout=True).batch_size(200)
        try:
            for doc in cursor:
                yield doc
        finally:
            cursor.close()

# ----------------------------
# MAIN
# ----------------------------
client = MongoClient(MONGO_URI)
db = client[DB_NAME]
src = db[SRC_COLL]
tgt = db[TGT_COLL]

df = pd.read_csv(CSV_PATH, dtype=str).fillna("")
csv_cols = list(df.columns)

doc_gen = mongo_stream(src)

batch = []
inserted = 0

for row_idx, row in df.iterrows():
    src_doc = next(doc_gen)
    new_doc = copy.deepcopy(src_doc)
    new_doc.pop("_id", None)

    # Build mapping per document (schema-safe)
    col_to_path = build_case_sensitive_mapping(src_doc, csv_cols)

    for col in csv_cols:
        path = col_to_path.get(col)
        if not path:
            continue

        raw = row[col]
        if SKIP_BLANKS and isinstance(raw, str) and raw.strip() == "":
            continue

        set_by_path(new_doc, path, coerce(raw))

    new_doc["_test_meta"] = {
        "csv_row": int(row_idx),
        "source_doc_id": str(src_doc.get("_id")),
        "created_at": datetime.utcnow()
    }

    batch.append(new_doc)

    if len(batch) >= BATCH_SIZE:
        tgt.insert_many(batch)
        inserted += len(batch)
        batch = []

if batch:
    tgt.insert_many(batch)
    inserted += len(batch)

print(f"Done ✔ CSV rows processed: {len(df)} | Inserted: {inserted}")
